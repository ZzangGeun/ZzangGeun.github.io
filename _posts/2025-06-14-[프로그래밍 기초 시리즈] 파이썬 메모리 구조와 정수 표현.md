---
layout: post
title: "파이썬 메모리 구조와 정수 표현"
date: 2025-06-14 11:00:00 +0900
categories: 프로그래밍 기초 시리즈
---

## 파이썬의 정수는 '무한대'까지 저장할 수 있을까?

앞에서 비트 바이트의 개념과 이진법 그리고 c언어와 파이썬의 데이터 타입과 표현 범위를 알아봤습니다. 

파이썬의 **int**는 일반적인 정수 타입들과 달리 **고정된 크기**가 없습니다. 내부적으로는 **무한 정밀도(arbitrary precision)** 를 지원하기 때문에, 이론상 메모리가 허용하는 한 얼마든지 큰 숫자를 저장할 수 있습니다.

이게 무슨 뜻일까요? C 언어에서 **int**는 32비트(혹은 64비트 등)로 정해진 크기를 가지며, 그 범위를 넘으면 오버플로우가 발생합니다. 반면 파이썬에서는 **2**1000** 같은 수조차도 문제없이 계산됩니다.

---

## 파이썬은 모든 것을 객체로 표현 (객체 지향)
파이썬은 철저하게 객체 지향 언어입니다. 숫자, 문자열, 리스트 같은 기본적인 자료형도 전부 내부적으로 객체로 표현되어 있습니다. 즉, **1, 3.14, 'hello', [1, 2, 3]** 같은 값들도 모두 클래스의 인스턴스이며, 메모리 상에 객체로 생성됩니다.

이는 저희가 보는 숫자, 문자의 값 이상으로 다양한 메타데이터를 포함한다는 뜻입니다.
이 특징을 통해 파이썬은 생산성과 효율성을 높이는 장점을 얻었지만 메모리 사용량이 많아지고 속도가 느려지는 단점을 얻기도 했습니다.

특히 십의 자리 정수를 저장하는데 4바이트만 쓰는 것이 아니라 28바이트를 사용하여 객체의 형태로 저장되기 때문에 더 많은 바이트를 사용하게 되는 것입니다.


## 내부 구조: 파이썬 `int` 객체의 메모리 사용 방식

파이썬의 정수형은 단순히 숫자만 저장하는 것이 아닙니다. 실제로는 객체로서 다음과 같은 구성 요소를 가집니다:

* 타입 정보
* 참조 카운트
* 실제 숫자 데이터 (**ob_digit**이라는 필드로 저장됨)

>### 작은 정수의 캐싱
파이썬은 성능을 위해 **작은 정수(-5 ~ 256)**는 미리 만들어두고 재사용합니다. 그래서 **1**, **100**, **256** 등은 전부 **같은 객체**를 참조합니다.
```python
import sys
print(sys.getsizeof(1))  # 28 바이트
print(sys.getsizeof(256))  # 28 바이트 (같음)
```
>> #### 왜 하필 **-5 ~ 256**인가요?
파이썬은 자주 사용되는 정수를 미리 만들어 두어 메모리 사용과 속도를 최적화합니다. 이 범위는 실제 파이썬 코드에서 **가장 자주 등장하는 정수들**입니다.
* **0 ~ 100** 정도의 양의 정수는 루프 인덱스나 기본 값 등으로 매우 자주 사용됩니다.
* 음수도 많이 쓰이는 **-1 ~ -5** 정도만 캐싱해두면 대부분의 경우를 커버할 수 있습니다.
* 특히 256은 바이트(1바이트 = 0~255) 단위 처리와도 관련이 있어 **실제 내부 구현에서 자주 쓰이기 때문**입니다.
이 범위는 **CPython**의 구현 결정이며, ***Objects/intobject.c**에서 아래와 같이 정의되어 있습니다:
```c
#define NSMALLPOSINTS           257  // 0 ~ 256 까지 총 257개
#define NSMALLNEGINTS           5    // -1 ~ -5 까지 총 5개
```
즉, 이 값들은 경험적으로 **가장 효율적인 범위**로 판단되어 하드코딩되어 있는 것이며, 사용자가 변경할 수는 없습니다.

### 큰 정수는 어떻게 될까?

```python
print(sys.getsizeof(2**30 - 1))  # 32 바이트
print(sys.getsizeof(2**60 - 1))  # 36 바이트
print(sys.getsizeof(2**1000 - 1))  # 160 바이트
```

숫자가 커질수록 메모리 사용량도 점차 커지며, 이는 **ob_digit** 배열의 크기가 증가하기 때문입니다.

---

## 파이썬은 메모리를 어떻게 관리할까?

C 같은 언어에서는 변수를 선언할 때 **int**, **float**처럼 **자료형과 크기를 명시**해야 하며, 이 정보는 컴파일 타임에 고정됩니다. 이를 **정적 타이핑(static typing)** 혹은 **정적 메모리 할당**이라고 부릅니다.

반면, 파이썬은 변수 선언 시 자료형을 명시하지 않고도 사용할 수 있으며, 값이 바뀌면 내부적으로 자료형도 바뀔 수 있습니다. 이를 **동적 타이핑(dynamic typing)**이라고 하며, 파이썬은 실행 중에 변수의 자료형과 필요한 메모리를 **자동으로 판단하고 할당**합니다.

예를 들어:

```python
a = 3         # 정수형 객체가 생성되어 'a'가 참조
a = "hello"   # 문자열 객체가 새로 생성되고 'a'가 참조를 바꿈
```

이처럼 파이썬은 변수명이 객체를 **가리키는 참조(reference)** 역할만 하며, 값이 바뀌면 새로운 객체를 생성하고 변수는 이를 다시 참조합니다. 이로 인해:

* 개발자는 **메모리 관리 부담에서 자유롭지만**,
* 내부적으로는 **객체 오버헤드와 참조 카운트**로 인해 메모리를 더 사용하게 됩니다.

이러한 특징은 다음과 같은 장점과 단점을 만듭니다:

| 장점           | 단점           |
| ------------ | ------------ |
| 오버플로우 걱정 없음  | 메모리 많이 씀     |
| 매우 큰 수 계산 가능 | 연산 속도 느림     |
| 개발 편의성 높음    | CPU 캐시 효율 낮음 |

---

## 그럼 파이썬은 어떻게 최적화를 해야 하나

파이썬 개발자들은 비트를 직접 다뤄서 최적화를 할 수 있는 방법이 거의 없습니다. 하지만 고성능이 필요한 경우는 C/C++로 작성된 최적화된 라이브러리를 사용할 수 있습니다.

### NumPy의 고정 크기 정수 사용

```python
import numpy as np
arr = np.array([1, 2, 3], dtype=np.int32)
print(arr.itemsize)  # 4 (바이트)
```

* 메모리를 효율적으로 사용하고, 수치 연산이 훨씬 빠릅니다.
* 배열 단위의 벡터 연산이 가능하므로 연산 속도도 빠름.

### **array** 모듈 활용 (간단한 수치 배열)

```python
from array import array
arr = array('i', [1, 2, 3])  # 'i'는 int(4바이트)
```

### Cython, Numba 사용

* 병목 구간을 C처럼 정적 타이핑하여 성능 극대화
* 반복문과 수치 연산이 많은 경우 유리

---

## 결론: 파이썬은 '편의성' 중심, 하지만 최적화는 가능

파이썬의 정수는 **생산성 중심의 설계** 덕분에 사용하기는 편리하지만, 메모리/속도 측면에서는 비효율적일 수 있습니다. 하지만:

* NumPy, array, Cython 등을 사용하면 저수준 언어에 가까운 성능 확보 가능
* 성능이 중요한 구간만 부분적으로 최적화하면 전체적인 생산성과 효율성을 모두 잡을 수 있음

다음 글에서는 파이썬의 이와 같은 구조가 **C 언어와 어떻게 다른지**, 그리고 **정수 표현에서 어떤 최적화 전략이 적용되는지**에 대해 비교해보겠습니다.
