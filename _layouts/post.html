---
layout: default
---
<div class="post-container">
  <article class="post h-entry" itemscope itemtype="http://schema.org/BlogPosting">    <header class="post-header">
      {%- if page.categories and page.categories.size > 0 -%}
        <div class="post-categories">
          {%- for category in page.categories -%}
            <span class="category-tag">{{ category }}</span>
          {%- endfor -%}
        </div>
      {%- endif -%}
      <h1 class="post-title p-name" itemprop="name headline">{{ page.title | escape }}</h1>
      <p class="post-meta">
        <time class="dt-published" datetime="{{ page.date | date_to_xmlschema }}" itemprop="datePublished">
          {%- assign date_format = site.minima.date_format | default: "%b %-d, %Y" -%}
          {{ page.date | date: date_format }}
        </time>
        {%- if page.author -%}
          • <span itemprop="author" itemscope itemtype="http://schema.org/Person"><span class="p-author h-card" itemprop="name">{{ page.author }}</span></span>
        {%- endif -%}</p>
    </header>

    <div class="post-content e-content" itemprop="articleBody">
      {{ content }}
    </div>

    {%- if site.disqus.shortname -%}
      {%- include disqus_comments.html -%}
    {%- endif -%}

    <a class="u-url" href="{{ page.url | relative_url }}" hidden></a>
  </article>

  <aside class="toc-sidebar">
    <div class="toc-wrapper">
      <h3 class="toc-title">목차</h3>
      <nav class="toc">
        <ul id="toc-list">
          <!-- TOC will be generated by JavaScript -->
        </ul>
      </nav>
    </div>
  </aside>
</div>

<script>
document.addEventListener('DOMContentLoaded', function() {
  const tocList = document.getElementById('toc-list');
  const headings = document.querySelectorAll('.post-content h1, .post-content h2, .post-content h3');
  
  if (headings.length === 0) {
    document.querySelector('.toc-sidebar').style.display = 'none';
    return;
  }
  
  headings.forEach((heading, index) => {
    // Add ID to heading if it doesn't have one
    if (!heading.id) {
      heading.id = 'heading-' + index;
    }
    
    // Create TOC item
    const li = document.createElement('li');
    li.className = 'toc-item toc-' + heading.tagName.toLowerCase();
    
    const a = document.createElement('a');
    a.href = '#' + heading.id;
    a.textContent = heading.textContent;
    a.className = 'toc-link';
    
    // Smooth scroll
    a.addEventListener('click', function(e) {
      e.preventDefault();
      document.getElementById(heading.id).scrollIntoView({
        behavior: 'smooth',
        block: 'start'
      });
    });
    
    li.appendChild(a);
    tocList.appendChild(li);
  });
  
  // Highlight current section
  function highlightCurrentSection() {
    const scrollPosition = window.scrollY + 100;
    let current = '';
    
    headings.forEach(heading => {
      const top = heading.offsetTop;
      if (scrollPosition >= top) {
        current = heading.id;
      }
    });
    
    document.querySelectorAll('.toc-link').forEach(link => {
      link.classList.remove('active');
      if (link.getAttribute('href') === '#' + current) {
        link.classList.add('active');
      }
    });
  }
  
  window.addEventListener('scroll', highlightCurrentSection);
  highlightCurrentSection();
});

// 코드 복사 기능
document.addEventListener('DOMContentLoaded', function() {
  // 라인 번호 요소들 제거
  function removeLineNumbers() {
    // 다양한 라인 번호 요소들 제거
    const lineNumberSelectors = [
      '.line-numbers-rows',
      '.gutter',
      '.rouge-gutter', 
      '.lineno',
      '.line-number',
      '.hljs-ln-numbers',
      '.rouge-table .rouge-gutter'
    ];
    
    lineNumberSelectors.forEach(selector => {
      document.querySelectorAll('.post-content ' + selector).forEach(element => {
        element.remove();
      });
    });
    
    // Rouge 테이블 구조 정리
    document.querySelectorAll('.post-content .rouge-table').forEach(table => {
      const codeCell = table.querySelector('.rouge-code');
      if (codeCell && table.parentNode) {
        // 코드 내용만 추출해서 테이블을 대체
        const pre = codeCell.querySelector('pre');
        if (pre) {
          table.parentNode.replaceChild(pre, table);
        }
      }
    });
  }
  
  // 라인 번호 제거 실행
  removeLineNumbers();
  
  // 모든 코드 블록 컨테이너 찾기 (highlight, highlighter-rouge, pre 등)
  function findCodeBlocks() {
    const codeBlocks = [];
    
    // highlight 컨테이너들 찾기
    document.querySelectorAll('.post-content .highlight, .post-content .highlighter-rouge').forEach(highlight => {
      if (!highlight.closest('.code-block')) {
        codeBlocks.push(highlight);
      }
    });
    
    // 독립적인 pre 태그들 찾기 (highlight로 감싸지지 않은)
    document.querySelectorAll('.post-content pre').forEach(pre => {
      if (!pre.closest('.highlight') && !pre.closest('.highlighter-rouge') && !pre.closest('.code-block')) {
        codeBlocks.push(pre);
      }
    });
    
    return codeBlocks;
  }
    // 연속된 코드 블록들을 그룹화
  function groupConsecutiveElements(elements) {
    if (elements.length === 0) return [];
    
    const groups = [];
    let currentGroup = [elements[0]];
    
    for (let i = 1; i < elements.length; i++) {
      const current = elements[i];
      const previous = elements[i - 1];
      
      // 두 요소 사이의 거리 계산
      let isConsecutive = false;
      let walker = previous.nextSibling;
      
      while (walker && walker !== current) {
        // 텍스트 노드가 공백만 포함하거나, 빈 p 태그인 경우 연속으로 간주
        if (walker.nodeType === Node.TEXT_NODE) {
          if (walker.textContent.trim().length > 0) {
            break; // 의미있는 텍스트가 있으면 연속이 아님
          }
        } else if (walker.nodeType === Node.ELEMENT_NODE) {
          if (walker.tagName === 'P' && walker.textContent.trim().length === 0) {
            // 빈 p 태그는 무시
          } else if (walker.tagName === 'BR') {
            // br 태그는 무시
          } else {
            break; // 다른 의미있는 요소가 있으면 연속이 아님
          }
        }
        walker = walker.nextSibling;
      }
      
      if (walker === current) {
        isConsecutive = true;
      }
      
      if (isConsecutive) {
        currentGroup.push(current);
      } else {
        groups.push([...currentGroup]);
        currentGroup = [current];
      }
    }
    
    groups.push(currentGroup);
    return groups;
  }
  
  const allCodeBlocks = findCodeBlocks();
  const codeGroups = groupConsecutiveElements(allCodeBlocks);
  
  codeGroups.forEach(group => {
    if (group.length > 0) {
      // 그룹의 첫 번째 요소 앞에 code-block div 생성
      const codeBlock = document.createElement('div');
      codeBlock.className = 'code-block';
      
      // 복사 버튼 생성
      const copyButton = document.createElement('button');
      copyButton.className = 'copy-button';
      copyButton.textContent = '복사';
      
      // 첫 번째 요소 앞에 code-block 삽입
      const firstElement = group[0];
      firstElement.parentNode.insertBefore(codeBlock, firstElement);
      codeBlock.appendChild(copyButton);
      
      // 모든 요소들을 code-block 안으로 이동
      group.forEach(element => {
        codeBlock.appendChild(element);
      });
      
      // 복사 이벤트 리스너 추가
      copyButton.addEventListener('click', () => {
        // 그룹 내 모든 코드 합치기
        let allText = '';
        
        group.forEach((element, index) => {
          let text = '';
          
          // highlight 또는 highlighter-rouge 컨테이너인 경우
          if (element.classList.contains('highlight') || element.classList.contains('highlighter-rouge')) {
            const codeElement = element.querySelector('code');
            if (codeElement) {
              text = codeElement.innerText;
            } else {
              const preElement = element.querySelector('pre');
              text = preElement ? preElement.innerText : element.innerText;
            }
          } else {
            // 일반 pre 태그인 경우
            const code = element.querySelector('code');
            text = code ? code.innerText : element.innerText;
          }
          
          allText += text;
          if (index < group.length - 1) {
            allText += '\n';
          }
        });
        
        navigator.clipboard.writeText(allText).then(() => {
          copyButton.textContent = '복사됨!';
          setTimeout(() => copyButton.textContent = '복사', 1500);
        }).catch(err => {
          console.error('복사 실패:', err);
          // fallback for older browsers
          const textArea = document.createElement('textarea');
          textArea.value = allText;
          document.body.appendChild(textArea);
          textArea.focus();
          textArea.select();
          try {
            document.execCommand('copy');
            copyButton.textContent = '복사됨!';
            setTimeout(() => copyButton.textContent = '복사', 1500);
          } catch (err) {
            console.error('Fallback 복사도 실패:', err);
          }
          document.body.removeChild(textArea);
        });
      });
    }
  });
});
</script>
